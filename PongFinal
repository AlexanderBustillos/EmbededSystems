#define BLACK 0x0000
#define WHITE 0xFFFF
#define GREY  0x5AEB

#include <TFT_eSPI.h>  // Hardware-specific library
#include <SPI.h>

TFT_eSPI tft = TFT_eSPI();  // Invoke custom library

// Screen dimensions
int16_t h = 320;
int16_t w = 480;

// Speed of the game (ball speed)
int dly = 5;

// Paddle dimensions
int16_t paddle_h = 60;
int16_t paddle_w = 4;

// Paddle positions
int16_t lpaddle_x = 0;
int16_t rpaddle_x = w - paddle_w;
int16_t lpaddle_y = 0;
int16_t rpaddle_y = h - paddle_h;

// Paddle movement directions (1 = down, -1 = up, 0 = stopped)
int16_t lpaddle_d = 1;
int16_t rpaddle_d = -1;

// Ball dimensions
int16_t ball_x = 2;
int16_t ball_y = 2;
int16_t oldball_x = 2;
int16_t oldball_y = 2;
int16_t ball_dx = 1;
int16_t ball_dy = 1;
int16_t ball_w = 8;
int16_t ball_h = 8;

// Dashline for the center
int16_t dashline_h = 6;
int16_t dashline_w = 2;
int16_t dashline_n = h / dashline_h;
int16_t dashline_x = w / 2 - 1;
int16_t dashline_y = dashline_h / 2;

// Game score
int16_t score = 0;  // Replacing rscore with score for left paddle hits
int16_t highScore = 0;  // To store the highest score

// Joystick pins
#define JOY_X_PIN 39
#define JOY_Y_PIN 25
#define JOY_BUTTON_PIN 36

void setup(void) {
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(BLACK);

  pinMode(JOY_BUTTON_PIN, INPUT_PULLUP);  // Joystick button input

  initgame();
}

void loop() {
  delay(dly);

  if (digitalRead(JOY_BUTTON_PIN) == LOW) {
    restartGame();  // Call the restart function
    delay(500);  // Debounce the button press
  }
  lpaddle();
  rpaddle();
  midline();
  ball();
  displayScore();  // Display the left paddle's score
}

void restartGame() {
  // Reset score
  if (score > highScore) {
    highScore = score;  // Update high score if current score is higher
  }
  score = 0;

  // Reset paddles to starting positions
  lpaddle_y = random(0, h - paddle_h);
  rpaddle_y = random(0, h - paddle_h);

  // Reset ball to center
  ball_x = 2;
  ball_y = lpaddle_y + (paddle_h / 2);
  ball_dx = 1;
  ball_dy = 1;

  // Redraw the screen to reflect the reset state
  tft.fillScreen(BLACK);
  midline();
  tft.fillRect(lpaddle_x, lpaddle_y, paddle_w, paddle_h, WHITE);
  tft.fillRect(rpaddle_x, rpaddle_y, paddle_w, paddle_h, WHITE);
  tft.fillRect(ball_x, ball_y, ball_w, ball_h, WHITE);
}

void initgame() {
  lpaddle_y = random(0, h - paddle_h);
  rpaddle_y = random(0, h - paddle_h);

  // Ball is placed in the center of the left paddle
  ball_y = lpaddle_y + (paddle_h / 2);

  midline();
}

void midline() {
  // Redraw the dashed center line
  if ((ball_x < dashline_x - ball_w) && (ball_x > dashline_x + dashline_w)) return;

  tft.startWrite();
  tft.setAddrWindow(dashline_x, 0, dashline_w, h);

  for (int16_t i = 0; i < dashline_n; i += 2) {
    tft.pushColor(WHITE, dashline_w * dashline_h);  // push dash pixels
    tft.pushColor(BLACK, dashline_w * dashline_h);  // push gap pixels
  }

  tft.endWrite();
}

void lpaddle() {
  // Clear old paddle position
  tft.fillRect(lpaddle_x, lpaddle_y, paddle_w, paddle_h, BLACK);

  // Read joystick Y-axis to control the left paddle
  int joystickY = analogRead(JOY_Y_PIN);
  
  // Map joystick position to the middle and adjust for slower movement
  int targetY = map(joystickY, 0, 4095, 0, h - paddle_h);

  // Slow down the paddle's movement: move gradually towards the target position
  if (lpaddle_y < targetY) {
    lpaddle_y += 1; // Adjust the increment value for slower movement
  } 
  else if (lpaddle_y > targetY) {
    lpaddle_y -= 1; // Adjust the decrement value for slower movement
  }

  // Prevent the paddle from going out of bounds
  if (lpaddle_y < 0) lpaddle_y = 0;
  if (lpaddle_y > h - paddle_h) lpaddle_y = h - paddle_h;

  // Draw the paddle at the new position
  tft.fillRect(lpaddle_x, lpaddle_y, paddle_w, paddle_h, WHITE);
}

void rpaddle() {
  // Simple AI for the right paddle (following the ball)
  if (rpaddle_d == 1) {
    tft.fillRect(rpaddle_x, rpaddle_y, paddle_w, 1, BLACK);
  } 
  else if (rpaddle_d == -1) {
    tft.fillRect(rpaddle_x, rpaddle_y + paddle_h - 1, paddle_w, 1, BLACK);
  }

  rpaddle_y = rpaddle_y + rpaddle_d;

  if (ball_dx == -1) rpaddle_d = 0;
  else {
    if (rpaddle_y + paddle_h / 2 == ball_y) rpaddle_d = 0;
    else if (rpaddle_y + paddle_h / 2 > ball_y) rpaddle_d = -1;
    else rpaddle_d = 1;
  }

  if (rpaddle_y + paddle_h >= h && rpaddle_d == 1) rpaddle_d = 0;
  else if (rpaddle_y <= 0 && rpaddle_d == -1) rpaddle_d = 0;

  tft.fillRect(rpaddle_x, rpaddle_y, paddle_w, paddle_h, WHITE);
}

void ball() {
  ball_x = ball_x + ball_dx;
  ball_y = ball_y + ball_dy;

  // Ball collision with left paddle
  if (ball_dx == -1 && ball_x == paddle_w && ball_y + ball_h >= lpaddle_y && ball_y <= lpaddle_y + paddle_h) {
    ball_dx = ball_dx * -1;  // Reverse horizontal direction
    // Randomize speed after hitting the left paddle
    ball_dx = random(-3, -1);  // Speed range for left paddle hit (slower speeds)
    ball_dy = random(-2, 2);  // Random vertical speed for variation
    score++;  // Increment score for left paddle hit
  }
  // Ball collision with right paddle
  else if (ball_dx == 1 && ball_x + ball_w == w - paddle_w && ball_y + ball_h >= rpaddle_y && ball_y <= rpaddle_y + paddle_h) {
    ball_dx = ball_dx * -1;  // Reverse horizontal direction
    // Randomize speed after hitting the right paddle
    ball_dx = random(1, 3);  // Speed range for right paddle hit (slightly faster speeds)
    ball_dy = random(-2, 2);  // Random vertical speed for variation
  }

  // Ball out of bounds
  if ((ball_dx == 1 && ball_x >= w) || (ball_dx == -1 && ball_x + ball_w < 0)) {
    dly = 5;  // Delay for game over or reset
  }

  // Ball collision with top and bottom walls
  if (ball_y > h - ball_w || ball_y < 0) {
    ball_dy = ball_dy * -1;  // Reverse vertical direction
    ball_y += ball_dy;  // Keep ball in bounds
  }

  // Draw ball at new position
  tft.fillRect(oldball_x, oldball_y, ball_w, ball_h, BLACK);  // Clear old ball position
  tft.fillRect(ball_x, ball_y, ball_w, ball_h, WHITE);  // Draw new ball position

  oldball_x = ball_x;
  oldball_y = ball_y;
}


void displayScore() {
  // Clear the score area before updating
  tft.fillRect(w / 4, 10, 100, 20, BLACK);

  // Display score for left paddle
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.setCursor(w / 4, 10);  // Adjust position to display score
  tft.print("Score: ");
  tft.print(score);

  // Display high score
  tft.setCursor(w / 4, 40);  // Adjust position for high score
  tft.print("High Score: ");
  tft.print(highScore);
}
